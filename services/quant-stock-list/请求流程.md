好的，小李！我们来完整梳理一下 **`quant-stock-list` 子模块中布隆过滤器的应用流程**，并详细讲解每个步骤，确保你对它的工作原理有清晰的理解。

### 整体流程：**用户请求 -> 缓存查询 -> 布隆过滤器验证 -> 数据回源 -> 缓存更新**

---

## 1. **用户请求**：用户发起查询请求

用户发起一个 **GET 请求**，如：

* `/api/v1/stable-picks/daily`（查询每日稳定精选股票）

在 Controller 层，**`StablePicksController#queryDailyPicks`** 接收这个请求，并进行初步的参数验证。

---

## 2. **请求参数封装与校验**

* Controller 将请求参数（如交易日、策略等）封装为 **`StablePicksQueryDTO`**，方便后续传递和校验。
* 经过校验后，调用 **`StablePicksServiceImpl#queryDailyPicks`** 执行业务逻辑。

---

## 3. **布隆过滤器验证（关键步骤）**

在 **`StablePicksServiceImpl#queryDailyPicks`** 方法中，布隆过滤器首先用于快速检查该交易日是否有效：

* **布隆过滤器检验**：调用 **`StablePicksBloomFilter#mightContainTradeDate`** 方法来校验 **交易日是否在有效范围内**。

  **流程**：

    1. **布隆过滤器检测**：通过布隆过滤器检查该交易日是否存在于已处理的集合中。
    2. **有效交易日**：如果交易日存在（布隆过滤器返回“存在”），继续执行后续的缓存和数据库查询。
    3. **非法日期处理**：如果布隆过滤器返回“不存在”，则立即**返回错误**，抛出 `BusinessException`，防止继续查询数据库。

> **作用**：通过布隆过滤器，系统能够**快速过滤掉非法请求**，避免对数据库和缓存的无效查询。布隆过滤器的误判率较低，但能够有效减少不必要的系统开销。

---

## 4. **多级缓存查询**：查询 Caffeine 和 Redis

* **缓存查询**：进入 **`queryWithCache`** 方法，按顺序查询 **Caffeine 本地缓存（L1）** 和 **Redis 分布式缓存（L2）**。

  **流程**：

    * **查询本地缓存 Caffeine**：首先检查 Caffeine 本地缓存（通过 `StablePicksCacheRepository#getLocal`），如果命中且数据没有过期，则返回缓存结果。
    * **查询 Redis 分布式缓存**：如果 Caffeine 本地缓存未命中，接着查询 Redis 缓存（通过 `StablePicksCacheRepository#getDistributed`）。
    * **缓存命中**：如果 Redis 缓存命中，直接返回缓存数据。

> **缓存未命中**：如果 Caffeine 和 Redis 都未命中，进入数据库查询流程。

---

## 5. **异步缓存刷新**：软过期策略

* **软过期刷新机制**：如果缓存已经过期，但**仍然可用**，**异步刷新**机制启动，以避免在主线程中阻塞查询请求。

  **流程**：

    * **触发异步刷新**：如果缓存过期，系统会通过 **`TaskScheduler`** 启动异步任务，调用 **`triggerAsyncRefreshIfNecessary`** 刷新缓存。这样可以**避免线程阻塞**，提高响应速度。

> **作用**：避免缓存数据过期导致的延迟，保证用户查询的高效性，同时不阻塞其他请求。

---

## 6. **分布式锁控制**：防止缓存击穿

* **Redisson 分布式锁**：如果缓存未命中，系统会使用 **Redisson 分布式锁** 来保证**同一数据只有一个请求去查询数据库**，防止并发查询时多次访问数据库。

  **流程**：

    1. **获取分布式锁**：调用 **`StablePicksLockManager#executeWithLock`** 获取分布式锁（锁的名称是根据缓存 Key 自动生成的）。
    2. **查询数据库**：如果获取到锁，查询数据库并将结果写入缓存。
    3. **锁释放**：数据查询完成后，锁会被释放，其他请求可以继续查询。

> **作用**：通过分布式锁机制，防止多个请求同时查询数据库，避免 **缓存击穿** 导致数据库压力过大。

---

## 7. **数据库回源**：查询数据库并更新缓存

* **回源查询**：当缓存未命中且分布式锁成功获取时，系统会通过 `StablePicksRepository#queryDaily` 查询数据库，获取数据。

  **流程**：

    1. **数据库查询**：通过 **MyBatis** 执行 SQL 查询，将数据转换为领域模型（`StablePick`）。
    2. **数据转换**：使用 **`StablePicksAssembler`** 将领域模型转换为 `StablePicksVO`，并进行字段序列化。
    3. **缓存更新**：将查询结果写入 **Caffeine 本地缓存** 和 **Redis 分布式缓存**，并设置过期时间（TTL）和随机抖动时间，防止缓存雪崩。

> **作用**：数据库查询结果通过缓存层写回，确保下次查询时可以命中缓存，减少数据库访问次数。

---

## 8. **返回响应**：将结果返回给前端

* **统一响应格式**：Controller 将查询结果封装成统一格式 `Result.success`，并返回给前端。

  **流程**：

    1. **分页结果**：使用 `Result.success` 方法将 `PageResult<StablePicksVO>` 封装成响应，返回给前端。
    2. **响应数据**：返回给前端的数据包括稳定精选股票的相关信息，按照分页返回。

> **作用**：通过统一的响应格式，确保前端能够接收到一致的数据格式，方便后续的展示与使用。

---

## 总结：流程回顾

1. **用户请求** -> Controller 接收请求并校验参数。
2. **布隆过滤器验证** -> 判断交易日是否有效，非法日期直接返回错误。
3. **缓存查询** -> 查询 Caffeine 本地缓存，未命中则查询 Redis 分布式缓存。
4. **缓存未命中** -> 使用分布式锁，防止多个请求同时查询数据库。
5. **数据库查询** -> 查询数据库，并将结果更新到缓存中。
6. **返回响应** -> 将结果统一封装并返回给前端。

---

### 关键点：

* **布隆过滤器**：通过它的快速存在性校验，减少了无效查询，降低了数据库压力。
* **缓存机制**：结合 **Caffeine** 和 **Redis**，实现了多级缓存和缓存过期、异步刷新机制，确保高效的数据访问。
* **分布式锁**：使用 **Redisson** 锁控制数据库访问，防止缓存击穿，保证数据一致性。
